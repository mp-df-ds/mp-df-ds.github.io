<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Quadratic Bezier Curve</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .plot-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 400px;
        }
        canvas {
            border: 1px solid #000;
            background-color: white;
            cursor: move;
        }
        h1 {
            color: #333;
        }
        .info {
            margin-top: 20px;
            max-width: 600px;
            background: white;
            padding: 15px;
            border-radius: 5px;
        }
        .color-legend {
            width: 380px;
            height: 20px;
            margin: 10px 0;
            background: linear-gradient(to right, 
                #000764, #0c2c84, #225ea8, #1d91c0, 
                #41b6c4, #7fcdbb, #c7e9b4, #ffffcc, 
                #ffeda0, #feb24c, #fd8d3c, #fc4e2a, 
                #e31a1c, #b10026, #800026);
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            width: 380px;
            margin: 0 0 10px 0;
            font-size: 12px;
        }
        .control-bar {
            width: 380px;
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-bar label {
            font-weight: bold;
            min-width: 100px;
        }
        .control-bar input[type="range"] {
            flex: 1;
        }
        .control-bar .value {
            min-width: 50px;
            text-align: right;
        }
        .plot-description {
            margin-top: 15px;
            font-size: 16px;
            color: #333;
            width: 380px;
            text-align: center;
            line-height: 1.5;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .plot-container:first-child .plot-description {
            margin-top: 75px;  /* Increased margin to match height of other plots */
        }
        .gif-section {
            margin-top: 40px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .gif-container {
            display: flex;
            flex-wrap: nowrap;  /* Prevent wrapping to new line */
            justify-content: center;
            gap: 30px;
            max-width: 1240px;
            margin: 0 auto;
            padding: 20px;
            overflow-x: auto;  /* Allow horizontal scrolling if needed */
        }
        .gif-item {
            flex: 0 0 350px;  /* Fixed width, no growing or shrinking */
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        .gif-item:hover {
            transform: translateY(-5px);
        }
        .gif-item img {
            width: 100%;
            height: auto;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .gif-item h4 {
            color: #333;
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 18px;
        }
        .gif-item p {
            color: #666;
            text-align: center;
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
        }
        .author-info {
            text-align: center;
            margin-bottom: 20px;
            color: #666;
            font-size: 18px;
            line-height: 1.6;
        }
        .author-info a {
            color: #225ea8;
            text-decoration: none;
            transition: color 0.2s;
        }
        .author-info a:hover {
            color: #1d91c0;
        }
        .button-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .button-link {
            display: inline-flex;
            align-items: center;
            padding: 10px 20px;
            background-color: #225ea8;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .button-link:hover {
            background-color: #1d91c0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .button-link svg {
            margin-right: 8px;
            width: 20px;
            height: 20px;
        }
    </style>
</head>
<body>
    <h1>From Movement Primitive to Distance Field to Dynamical System</h1>

    <div class="author-info">
        <p>Yiming Li and Sylvain Calinon</p>
        <p>Idiap Research Institute and EPFL</p>
    </div>

    <div class="button-container">
        <a href="https://arxiv.org/pdf/2504.09705" class="button-link">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
            Paper
        </a>
        <a href="https://github.com/mp-df-ds/mp-df-ds" class="button-link">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
            Code
        </a>
    </div>

    <div class="container">
        <div class="plot-container">
            <h3>Quadratic Bezier Curve (with 2 segments)</h3>
            <canvas id="curveCanvas" width="400" height="400"></canvas>
            <p class="plot-description">A quadratic spline with two segments. The blue points are control points that shape the curve. The orange point marks the end of the curve. Drag any point to modify the curve while maintaining smoothness.</p>
        </div>
        <div class="plot-container">
            <h3>Distance Field</h3>
            <canvas id="distanceFieldCanvas" width="400" height="400"></canvas>
            <div class="color-legend"></div>
            <div class="legend-labels">
                <span>Close</span>
                <span>Far</span>
            </div>
            <p class="plot-description">Distance field of the quadratic bezier curve. Blue means close to the curve, red means far away. Click and drag to see the gradient direction at any point.</p>
        </div>
        <div class="plot-container">
            <h3>Dynamical System</h3>
            <canvas id="autonomousCanvas" width="400" height="400"></canvas>
            <div class="control-bar">
                <label for="lambdaSlider">Lambda (λ):</label>
                <input type="range" id="lambdaSlider" min="0.5" max="20" step="0.1" value="10.0">
                <span class="value" id="lambdaValue">10.0</span>
            </div>
            <p class="plot-description">Dynamical system derived from the quadratic bezier curve and its distance field. The magenta point can be dragged to start a new path. All paths lead to the orange equilibrium point. Adjust λ to control the balance between following the curve and moving toward it.</p>
        </div>
    </div>

    <!-- <div class="info">
        <p><strong>Click and drag</strong> on the distance field to see the closest point and gradient vector.</p>
    </div> -->

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;
        
        uniform vec2 p0;
        uniform vec2 p1;
        uniform vec2 p2;
        uniform vec2 p3;
        uniform vec2 p4;
        uniform vec2 iResolution;
        uniform vec2 clickPosition;
        uniform bool showGradient;
        
        // Quadratic bezier evaluation
        vec2 evaluateBezier(vec2 A, vec2 B, vec2 C, float t) {
            float t1 = 1.0 - t;
            return t1*t1*A + 2.0*t1*t*B + t*t*C;
        }
        
        // Signed distance to quadratic bezier curve with analytical gradient
        // Returns vec3(distance, closest_t, is_valid)
        vec3 sdBezierWithT(vec2 pos, vec2 A, vec2 B, vec2 C) {
            vec2 a = B - A;
            vec2 b = A - 2.0*B + C;
            vec2 c = a * 2.0;
            vec2 d = A - pos;
            
            float kk = 1.0 / dot(b,b);
            float kx = kk * dot(a,b);
            float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
            float kz = kk * dot(d,a);
            
            float res = 0.0;
            float t_res = 0.0;
            bool valid = true;
            
            float p = ky - kx*kx;
            float p3 = p*p*p;
            float q = kx*(2.0*kx*kx - 3.0*ky) + kz;
            float h = q*q + 4.0*p3;
            
            if(h >= 0.0) { 
                h = sqrt(h);
                vec2 x = (vec2(h, -h) - q) / 2.0;
                vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
                float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);
                t_res = t;
                vec2 q = d + (c + b*t)*t;
                res = dot(q,q);
            } else {
                float z = sqrt(-p);
                float v = acos(q/(p*z*2.0)) / 3.0;
                float m = cos(v);
                float n = sin(v)*1.732050808;
                vec3 t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);
                
                vec2 qx = d + (c + b*t.x)*t.x;
                float dx = dot(qx, qx);
                
                vec2 qy = d + (c + b*t.y)*t.y;
                float dy = dot(qy, qy);
                
                vec2 qz = d + (c + b*t.z)*t.z;
                float dz = dot(qz, qz);
                
                // Find minimum
                float min_d = dx;
                t_res = t.x;
                
                if(dy < min_d) {
                    min_d = dy;
                    t_res = t.y;
                }
                
                if(dz < min_d) {
                    min_d = dz;
                    t_res = t.z;
                }
                
                res = min_d;
            }
            
            return vec3(sqrt(res), t_res, valid ? 1.0 : 0.0);
        }
        
        // Simplified distance-only function
        float sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C) {
            return sdBezierWithT(pos, A, B, C).x;
        }
        
        // Get analytical gradient at a point
        vec2 getBezierGradient(vec2 pos, vec2 A, vec2 B, vec2 C) {
            // Find the closest point on the curve
            vec3 closestInfo = sdBezierWithT(pos, A, B, C);
            float t = closestInfo.y;
            
            // Get the closest point on the curve
            vec2 closestPoint = evaluateBezier(A, B, C, t);
            
            // The gradient points from the query point to the closest point on the curve
            vec2 gradient = normalize(closestPoint - pos);
            
            return gradient;
        }
        
        // Function to compute minimum distance to two quadratic Bezier curves
        float sdTwoBeziers(vec2 pos, vec2 q1, vec2 q2, vec2 q3, vec2 q4, vec2 q5) {
            // First segment: q1, q2, q3
            float d1 = sdBezier(pos, q1, q2, q3);
            
            // Second segment: q3, q4, q5
            float d2 = sdBezier(pos, q3, q4, q5);
            
            // Return minimum distance
            return min(d1, d2);
        }
        
        // Enhanced colormap with more layers
        vec3 enhancedColorMap(float t) {
            // 15-color palette inspired by scientific colormaps
            const vec3 c1 = vec3(0.0, 0.027, 0.392);    // Deep blue
            const vec3 c2 = vec3(0.047, 0.173, 0.516);  // Dark blue
            const vec3 c3 = vec3(0.133, 0.369, 0.659);  // Medium blue
            const vec3 c4 = vec3(0.114, 0.569, 0.753);  // Light blue
            const vec3 c5 = vec3(0.255, 0.714, 0.767);  // Cyan
            const vec3 c6 = vec3(0.498, 0.804, 0.733);  // Turquoise
            const vec3 c7 = vec3(0.780, 0.914, 0.706);  // Light green
            const vec3 c8 = vec3(1.0, 1.0, 0.8);        // Light yellow
            const vec3 c9 = vec3(1.0, 0.931, 0.627);    // Pale yellow
            const vec3 c10 = vec3(0.996, 0.698, 0.298); // Light orange
            const vec3 c11 = vec3(0.992, 0.553, 0.235); // Medium orange
            const vec3 c12 = vec3(0.988, 0.306, 0.164); // Dark orange
            const vec3 c13 = vec3(0.890, 0.102, 0.110); // Red
            const vec3 c14 = vec3(0.694, 0.0, 0.149);   // Dark red
            const vec3 c15 = vec3(0.502, 0.0, 0.149);   // Maroon
            
            float normalized = clamp(t, 0.0, 1.0);
            normalized = pow(normalized, 0.8); // Slightly emphasize lower values
            
            if (normalized < 1.0/14.0) {
                return mix(c1, c2, normalized * 14.0);
            } else if (normalized < 2.0/14.0) {
                return mix(c2, c3, (normalized - 1.0/14.0) * 14.0);
            } else if (normalized < 3.0/14.0) {
                return mix(c3, c4, (normalized - 2.0/14.0) * 14.0);
            } else if (normalized < 4.0/14.0) {
                return mix(c4, c5, (normalized - 3.0/14.0) * 14.0);
            } else if (normalized < 5.0/14.0) {
                return mix(c5, c6, (normalized - 4.0/14.0) * 14.0);
            } else if (normalized < 6.0/14.0) {
                return mix(c6, c7, (normalized - 5.0/14.0) * 14.0);
            } else if (normalized < 7.0/14.0) {
                return mix(c7, c8, (normalized - 6.0/14.0) * 14.0);
            } else if (normalized < 8.0/14.0) {
                return mix(c8, c9, (normalized - 7.0/14.0) * 14.0);
            } else if (normalized < 9.0/14.0) {
                return mix(c9, c10, (normalized - 8.0/14.0) * 14.0);
            } else if (normalized < 10.0/14.0) {
                return mix(c10, c11, (normalized - 9.0/14.0) * 14.0);
            } else if (normalized < 11.0/14.0) {
                return mix(c11, c12, (normalized - 10.0/14.0) * 14.0);
            } else if (normalized < 12.0/14.0) {
                return mix(c12, c13, (normalized - 11.0/14.0) * 14.0);
            } else if (normalized < 13.0/14.0) {
                return mix(c13, c14, (normalized - 12.0/14.0) * 14.0);
            } else {
                return mix(c14, c15, (normalized - 13.0/14.0) * 14.0);
            }
        }
        
        void mainImage(out vec4 fragColor, in vec2 fragCoord) {
            // Normalized pixel coordinates (from 0 to 1)
            vec2 uv = fragCoord / iResolution.xy;
            
            // Compute distance to both bezier curves
            float d = sdTwoBeziers(uv, p0, p1, p2, p3, p4);
            
            // Scale the distance for better visualization
            float scaledDistance = clamp(d * 5.0, 0.0, 1.0);
            
            // Apply enhanced color map
            vec3 col = enhancedColorMap(scaledDistance);
            
            // Add grid
            vec2 grid = abs(fract(uv * 10.0) - 0.5);
            float gridLine = smoothstep(0.02, 0.0, max(grid.x, grid.y));
            col = mix(col, vec3(0.8, 0.8, 0.8), gridLine * 0.3);
            
            // Visualize the curves themselves
            float lineWidth = 0.004;
            float edge1 = smoothstep(lineWidth, 0.0, sdBezier(uv, p0, p1, p2));
            float edge2 = smoothstep(lineWidth, 0.0, sdBezier(uv, p2, p3, p4));
            col = mix(col, vec3(0.0, 0.0, 0.0), max(edge1, edge2));
            
            // Show gradient vector if requested
            if (showGradient) {
                // Find the closest point on both curves
                vec3 closestInfo1 = sdBezierWithT(clickPosition, p0, p1, p2);
                vec3 closestInfo2 = sdBezierWithT(clickPosition, p2, p3, p4);
                
                // Use the closer one
                vec3 closestInfo = closestInfo1.x < closestInfo2.x ? closestInfo1 : closestInfo2;
                float t_param = closestInfo.y;
                
                // Get the closest point on the curve
                vec2 closestPoint = closestInfo1.x < closestInfo2.x ? 
                    evaluateBezier(p0, p1, p2, t_param) : 
                    evaluateBezier(p2, p3, p4, t_param);
                
                // Get the gradient (direction from closest point to click position)
                vec2 gradient = normalize(closestPoint - clickPosition);
                
                // Highlight the click position
                if (length(uv - clickPosition) < 0.01) {
                    col = vec3(1.0, 1.0, 1.0);
                }
                
                // Draw line from click point to closest point
                float lineThickness = 0.002;
                vec2 dir = closestPoint - clickPosition;
                float lineLength = length(dir);
                dir = normalize(dir);
                
                // Check if point is near the line
                float t_line = clamp(dot(uv - clickPosition, dir) / lineLength, 0.0, 1.0);
                vec2 pointOnLine = clickPosition + t_line * lineLength * dir;
                float distToLine = distance(uv, pointOnLine);
                
                if (distToLine < lineThickness) {
                    col = vec3(1.0, 0.0, 0.0); // Red line to closest point
                }
                
                // Draw the normal vector (perpendicular to the curve at closest point)
                // Compute tangent at the closest point
                float delta = 0.01;
                vec2 pointBefore = closestInfo1.x < closestInfo2.x ? 
                    evaluateBezier(p0, p1, p2, max(0.0, t_param - delta)) : 
                    evaluateBezier(p2, p3, p4, max(0.0, t_param - delta));
                vec2 pointAfter = closestInfo1.x < closestInfo2.x ? 
                    evaluateBezier(p0, p1, p2, min(1.0, t_param + delta)) : 
                    evaluateBezier(p2, p3, p4, min(1.0, t_param + delta));
                vec2 tangent = normalize(pointAfter - pointBefore);
                vec2 normal = vec2(-tangent.y, tangent.x);  // Perpendicular to tangent
                
                // Draw normal vector
                float gradLineLength = 0.08;
                dir = normal;
                
                t_line = clamp(dot(uv - closestPoint, dir) / gradLineLength, 0.0, 1.0);
                pointOnLine = closestPoint + t_line * gradLineLength * dir;
                distToLine = distance(uv, pointOnLine);
                
                if (distToLine < lineThickness) {
                    col = vec3(0.0, 1.0, 0.0); // Green line for normal/gradient
                }
                
                // Draw anti-normal vector (in opposite direction)
                dir = -normal;
                t_line = clamp(dot(uv - closestPoint, dir) / gradLineLength, 0.0, 1.0);
                pointOnLine = closestPoint + t_line * gradLineLength * dir;
                distToLine = distance(uv, pointOnLine);
                
                if (distToLine < lineThickness) {
                    col = vec3(0.0, 1.0, 0.0); // Green line for normal/gradient (opposite side)
                }
                
                // Draw closest point
                if (distance(uv, closestPoint) < 0.01) {
                    col = vec3(1.0, 1.0, 0.0); // Yellow for closest point
                }
                
                // Add contour line through the point at same distance
                float clickDistance = closestInfo.x;
                float contourDist = abs(d - clickDistance);
                float contourWidth = 0.001;
                if (contourDist < contourWidth) {
                    col = mix(col, vec3(1.0, 1.0, 1.0), 0.5);
                }
            }
            
            fragColor = vec4(col, 1.0);
        }
        
        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    </script>

    <script>
        // Add vector operations
        function vec2(x, y) {
            return { x: x, y: y };
        }
        
        function add(a, b) {
            return { x: a.x + b.x, y: a.y + b.y };
        }
        
        function sub(a, b) {
            return { x: a.x - b.x, y: a.y - b.y };
        }
        
        function mul(a, s) {
            if (typeof s === 'number') {
                return { x: a.x * s, y: a.y * s };
            } else {
                return { x: a.x * s.x, y: a.y * s.y };
            }
        }
        
        function length(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        }
        
        function normalize(v) {
            const len = length(v);
            if (len === 0) return { x: 0, y: 0 };
            return { x: v.x / len, y: v.y / len };
        }
        
        function dot(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        
        // Bezier curve functions
        function evaluateBezier(A, B, C, t) {
            const t1 = 1.0 - t;
            return add(
                add(
                    mul(A, t1 * t1),
                    mul(B, 2.0 * t1 * t)
                ),
                mul(C, t * t)
            );
        }
        
        function sdBezierWithT(pos, A, B, C) {
            // Analytical solution for quadratic bezier curve
            const a = sub(B, A);
            const b = add(sub(A, mul(B, 2.0)), C);
            const c = mul(a, 2.0);
            const d = sub(A, pos);
            
            // Compute coefficients for the cubic equation
            const kk = 1.0 / dot(b, b);
            const kx = kk * dot(a, b);
            const ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;
            const kz = kk * dot(d, a);
            
            let res = 0.0;
            let t_res = 0.0;
            
            const p = ky - kx*kx;
            const p3 = p*p*p;
            const q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;
            const h = q*q + 4.0 * p3;
            
            if (h >= 0.0) {
                // One real root
                const h_sqrt = Math.sqrt(h);
                const x = (h_sqrt - q) / 2.0;
                const uv = Math.sign(x)*Math.pow(Math.abs(x), 1.0/3.0);
                const t = Math.max(0.0, Math.min(1.0, uv - kx));
                t_res = t;
                const q_vec = add(d, add(mul(c, t), mul(b, t * t)));
                res = dot(q_vec, q_vec);
            } else {
                // Three real roots
                const z = Math.sqrt(-p);
                const v = Math.acos(q / (p * z * 2.0)) / 3.0;
                const m = Math.cos(v);
                const n = Math.sin(v)*1.732050808;
                const t1 = Math.max(0.0, Math.min(1.0, (m + m) * z - kx));
                const t2 = Math.max(0.0, Math.min(1.0, (-n - m) * z - kx));
                const t3 = Math.max(0.0, Math.min(1.0, (n - m) * z - kx));
                
                // Evaluate all three roots
                const q1 = add(d, add(mul(c, t1), mul(b, t1 * t1)));
                const d1 = dot(q1, q1);
                
                const q2 = add(d, add(mul(c, t2), mul(b, t2 * t2)));
                const d2 = dot(q2, q2);
                
                const q3 = add(d, add(mul(c, t3), mul(b, t3 * t3)));
                const d3 = dot(q3, q3);
                
                // Find minimum distance
                res = d1;
                t_res = t1;
                
                if (d2 < res) {
                    res = d2;
                    t_res = t2;
                }
                
                if (d3 < res) {
                    res = d3;
                    t_res = t3;
                }
            }
            
            return { x: Math.sqrt(res), y: t_res };
        }
        
        // Function to calculate gradient at a point (JavaScript version)
        function getBezierGradient(pos, A, B, C) {
            // Find closest point on both curves using numerical method
            let minDist = Infinity;
            let closestPoint = { x: 0, y: 0 };
            
            // Check first segment (Q1, Q2, Q3)
            for (let t = 0; t <= 1; t += 0.01) {
                const x = (1-t)*(1-t)*controlPoints[0].x + 2*(1-t)*t*controlPoints[1].x + t*t*controlPoints[2].x;
                const y = (1-t)*(1-t)*controlPoints[0].y + 2*(1-t)*t*controlPoints[1].y + t*t*controlPoints[2].y;
                
                const dist = Math.sqrt(
                    Math.pow(pos.x - x, 2) + 
                    Math.pow(pos.y - y, 2)
                );
                
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = { x, y };
                }
            }
            
            // Check second segment (Q3, Q4, Q5)
            for (let t = 0; t <= 1; t += 0.01) {
                const x = (1-t)*(1-t)*controlPoints[2].x + 2*(1-t)*t*controlPoints[3].x + t*t*controlPoints[4].x;
                const y = (1-t)*(1-t)*controlPoints[2].y + 2*(1-t)*t*controlPoints[3].y + t*t*controlPoints[4].y;
                
                const dist = Math.sqrt(
                    Math.pow(pos.x - x, 2) + 
                    Math.pow(pos.y - y, 2)
                );
                
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = { x, y };
                }
            }
            
            // Calculate gradient (direction from query point to closest point)
            const dx = closestPoint.x - pos.x;
            const dy = closestPoint.y - pos.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize the gradient
            return length > 0.0001 ? 
                { x: dx / length, y: dy / length } : 
                { x: 0, y: 0 };
        }

        // Function to calculate curve gradient at parameter t
        function getCurveGradient(A, B, C, t) {
            // First derivative of quadratic Bezier curve
            // B(t) = (1-t)²A + 2(1-t)tB + t²C
            // B'(t) = -2(1-t)A + 2(1-2t)B + 2tC
            const dx = -2 * (1 - t) * A.x + 2 * (1 - 2 * t) * B.x + 2 * t * C.x;
            const dy = -2 * (1 - t) * A.y + 2 * (1 - 2 * t) * B.y + 2 * t * C.y;
            
            // Second derivative for curvature
            // B''(t) = 2A - 4B + 2C
            const d2x = 2 * A.x - 4 * B.x + 2 * C.x;
            const d2y = 2 * A.y - 4 * B.y + 2 * C.y;
            
            // Calculate curvature
            const speed = Math.sqrt(dx * dx + dy * dy);
            const curvature = (dx * d2y - dy * d2x) / Math.pow(speed, 3);
            
            // If we're at the end point (t = 1), return zero gradient
            if (Math.abs(t - 1.0) < 0.001) {
                return { tangent: { x: 0, y: 0 }, curvature: 0, speed: 0 };
            }
            
            // Normalize the tangent vector
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length > 0) {
                return {
                    tangent: { x: dx / length, y: dy / length },
                    curvature: curvature,
                    speed: speed
                };
            }
            return { tangent: { x: 0, y: 0 }, curvature: 0, speed: 0 };
        }
        
        // Add stream plot point
        const streamPoint = { x: 0.3, y: 0.3, dragging: false };
        let trajectory = [];
        
        // Function to compute trajectory
        function computeTrajectory(startPoint, steps = 1000, stepSize = 0.005) {
            const trajectory = [startPoint];
            let currentPoint = { ...startPoint };
            let lastDistance = Infinity;
            let convergenceCount = 0;
            let stuckCount = 0;
            let lastPoint = { ...startPoint };
            
            // Get lambda value from slider
            const lambda = parseFloat(document.getElementById('lambdaSlider').value);
            
            for (let i = 0; i < steps; i++) {
                // Get gradient at current point
                const gradient = getBezierGradient(
                    vec2(currentPoint.x, currentPoint.y),
                    vec2(controlPoints[0].x, controlPoints[0].y),
                    vec2(controlPoints[1].x, controlPoints[1].y),
                    vec2(controlPoints[2].x, controlPoints[2].y)
                );
                
                // Find closest point on both curves and get curve gradient
                let minDist = Infinity;
                let closestT = 0;
                let closestSegment = 0;
                
                // Check first segment
                for (let t = 0; t <= 1; t += 0.001) {
                    const curveX = (1-t)*(1-t)*controlPoints[0].x + 2*(1-t)*t*controlPoints[1].x + t*t*controlPoints[2].x;
                    const curveY = (1-t)*(1-t)*controlPoints[0].y + 2*(1-t)*t*controlPoints[1].y + t*t*controlPoints[2].y;
                    
                    const dist = Math.sqrt(
                        Math.pow(curveX - currentPoint.x, 2) + 
                        Math.pow(curveY - currentPoint.y, 2)
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closestT = t;
                        closestSegment = 0;
                    }
                }
                
                // Check second segment
                for (let t = 0; t <= 1; t += 0.001) {
                    const curveX = (1-t)*(1-t)*controlPoints[2].x + 2*(1-t)*t*controlPoints[3].x + t*t*controlPoints[4].x;
                    const curveY = (1-t)*(1-t)*controlPoints[2].y + 2*(1-t)*t*controlPoints[3].y + t*t*controlPoints[4].y;
                    
                    const dist = Math.sqrt(
                        Math.pow(curveX - currentPoint.x, 2) + 
                        Math.pow(curveY - currentPoint.y, 2)
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closestT = t;
                        closestSegment = 1;
                    }
                }
                
                // Get curve gradient based on closest segment
                const curveGradient = closestSegment === 0 ? 
                    getCurveGradient(
                        { x: controlPoints[0].x, y: controlPoints[0].y },
                        { x: controlPoints[1].x, y: controlPoints[1].y },
                        { x: controlPoints[2].x, y: controlPoints[2].y },
                        closestT
                    ) :
                    getCurveGradient(
                        { x: controlPoints[2].x, y: controlPoints[2].y },
                        { x: controlPoints[3].x, y: controlPoints[3].y },
                        { x: controlPoints[4].x, y: controlPoints[4].y },
                        closestT
                    );
                
                // Calculate beta and alpha based on distance
                let beta = 1.0 / (1.0 + lambda * minDist);
                let alpha = 1.0 - beta;
                
                // If we're very close to the end point (Q5), only use distance gradient
                const endPoint = { x: controlPoints[4].x, y: controlPoints[4].y };
                const distToEnd = Math.sqrt(
                    Math.pow(currentPoint.x - endPoint.x, 2) + 
                    Math.pow(currentPoint.y - endPoint.y, 2)
                );
                
                if (distToEnd < 0.01) {
                    beta = 0;
                    alpha = 1;
                }
                
                // Combine the gradients
                let combinedX = -alpha * (-gradient.x) + beta * curveGradient.tangent.x;
                let combinedY = -alpha * (-gradient.y) + beta * curveGradient.tangent.y;
                
                // Normalize the combined vector if it's not zero
                const length = Math.sqrt(combinedX * combinedX + combinedY * combinedY);
                if (length > 0) {
                    combinedX = combinedX / length;
                    combinedY = combinedY / length;
                }
                
                // Adaptive step size based on distance to goal and curve
                let adaptiveStepSize = stepSize;
                
                // Increase step size when far from the curve or end point
                if (minDist > 0.1 || distToEnd > 0.2) {
                    adaptiveStepSize = stepSize * 3;
                }
                // Decrease step size when close to the end point
                else if (distToEnd < 0.05) {
                    adaptiveStepSize = stepSize * 0.3;
                }
                
                // Further reduce step size if we're stuck
                if (stuckCount > 10) {
                    adaptiveStepSize *= 0.5;
                }
                
                // Update position
                currentPoint.x += combinedX * adaptiveStepSize;
                currentPoint.y += combinedY * adaptiveStepSize;
                
                // Keep point within bounds
                currentPoint.x = Math.max(0, Math.min(1, currentPoint.x));
                currentPoint.y = Math.max(0, Math.min(1, currentPoint.y));
                
                // Check if we're stuck (not moving much)
                const movement = Math.sqrt(
                    Math.pow(currentPoint.x - lastPoint.x, 2) + 
                    Math.pow(currentPoint.y - lastPoint.y, 2)
                );
                
                if (movement < 0.0001) {
                    stuckCount++;
                    if (stuckCount > 20) {
                        // If stuck for too long, try to escape by moving directly towards the goal
                        const escapeX = endPoint.x - currentPoint.x;
                        const escapeY = endPoint.y - currentPoint.y;
                        const escapeLength = Math.sqrt(escapeX * escapeX + escapeY * escapeY);
                        if (escapeLength > 0) {
                            currentPoint.x += (escapeX / escapeLength) * stepSize;
                            currentPoint.y += (escapeY / escapeLength) * stepSize;
                        }
                    }
                } else {
                    stuckCount = 0;
                }
                
                // Check for convergence
                if (Math.abs(minDist - lastDistance) < 0.0001) {
                    convergenceCount++;
                    if (convergenceCount > 5) {
                        // If converged but not at goal, try to move towards goal
                        if (distToEnd > 0.01) {
                            const escapeX = endPoint.x - currentPoint.x;
                            const escapeY = endPoint.y - currentPoint.y;
                            const escapeLength = Math.sqrt(escapeX * escapeX + escapeY * escapeY);
                            if (escapeLength > 0) {
                                currentPoint.x += (escapeX / escapeLength) * stepSize;
                                currentPoint.y += (escapeY / escapeLength) * stepSize;
                                convergenceCount = 0;
                            }
                        } else {
                            break; // We've reached the goal
                        }
                    }
                } else {
                    convergenceCount = 0;
                }
                
                lastDistance = minDist;
                lastPoint = { ...currentPoint };
                
                trajectory.push({ ...currentPoint });
                
                // Stop if we've reached the end point
                if (distToEnd < 0.01) {
                    break;
                }
            }
            
            return trajectory;
        }
        
        // Initialize canvas elements
        const curveCanvas = document.getElementById('curveCanvas');
        const distanceFieldCanvas = document.getElementById('distanceFieldCanvas');
        const autonomousCanvas = document.getElementById('autonomousCanvas');
        const curveCtx = curveCanvas.getContext('2d');
        const autonomousCtx = autonomousCanvas.getContext('2d');
        
        // Initialize WebGL for distance field
        const gl = distanceFieldCanvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported in your browser');
        }
        
        // Compile shader
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Create shader program
        const fragmentShaderSource = document.getElementById('fragmentShader').text;
        const vertexShaderSource = `
            attribute vec2 aPosition;
            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }
        
        // Create a full-screen quad
        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const positionAttributeLocation = gl.getAttribLocation(program, 'aPosition');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Get uniform locations
        const p0Location = gl.getUniformLocation(program, 'p0');
        const p1Location = gl.getUniformLocation(program, 'p1');
        const p2Location = gl.getUniformLocation(program, 'p2');
        const p3Location = gl.getUniformLocation(program, 'p3');
        const p4Location = gl.getUniformLocation(program, 'p4');
        const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
        const clickPositionLocation = gl.getUniformLocation(program, 'clickPosition');
        const showGradientLocation = gl.getUniformLocation(program, 'showGradient');
        
        // Control points (normalized coordinates 0-1)
        const controlPoints = [
            { x: 0.1, y: 0.5, color: '#1f77b4', radius: 8, dragging: false },    // Q1
            { x: 0.3, y: 0.9, color: '#1f77b4', radius: 8, dragging: false },    // Q2
            { x: 0.5, y: 0.5, color: '#1f77b4', radius: 8, dragging: false },    // Q3
            { x: 0.7, y: 0.1, color: '#1f77b4', radius: 8, dragging: false },    // Q4
            { x: 0.9, y: 0.5, color: '#ff7f0e', radius: 8, dragging: false }     // Q5 (equilibrium point)
        ];
        
        // Debug point for curve gradient visualization
        const debugPoint = { x: 0.5, y: 0.5, dragging: false };
        
        // Click position for gradient visualization
        const clickPosition = { x: 0.5, y: 0.5 };
        let showGradient = false;
        let isDraggingGradientPoint = false;
        
        // Function to convert normalized coordinates to canvas pixels
        function toCanvasCoords(point) {
            return {
                x: point.x * curveCanvas.width,
                y: (1 - point.y) * curveCanvas.height
            };
        }
        
        // Function to convert canvas pixels to normalized coordinates
        function toNormalizedCoords(x, y) {
            return {
                x: x / curveCanvas.width,
                y: 1 - (y / curveCanvas.height)
            };
        }
        
        // Function to check if a point is inside a control point
        function isPointInControlPoint(mouseX, mouseY, point) {
            const canvasCoords = toCanvasCoords(point);
            const distance = Math.sqrt(
                Math.pow(mouseX - canvasCoords.x, 2) + 
                Math.pow(mouseY - canvasCoords.y, 2)
            );
            return distance <= point.radius;
        }
        
        // Function to update all plots
        function updateAll() {
            drawBezierCurve();
            updateDistanceField();
            // Recompute trajectory before drawing autonomous system
            trajectory = computeTrajectory(streamPoint);
            drawAutonomousSystem();
        }
        
        // Function to draw the bezier curve
        function drawBezierCurve() {
            const width = curveCanvas.width;
            const height = curveCanvas.height;
            
            // Clear canvas
            curveCtx.clearRect(0, 0, width, height);
            
            // Draw grid
            curveCtx.strokeStyle = '#ddd';
            curveCtx.lineWidth = 1;
            const gridSize = 10;
            
            for (let x = 0; x <= gridSize; x++) {
                const posX = (width / gridSize) * x;
                curveCtx.beginPath();
                curveCtx.moveTo(posX, 0);
                curveCtx.lineTo(posX, height);
                curveCtx.stroke();
            }
            
            for (let y = 0; y <= gridSize; y++) {
                const posY = (height / gridSize) * y;
                curveCtx.beginPath();
                curveCtx.moveTo(0, posY);
                curveCtx.lineTo(width, posY);
                curveCtx.stroke();
            }
            
            // Draw control lines
            curveCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            curveCtx.lineWidth = 1;
            curveCtx.beginPath();
            
            const q1 = toCanvasCoords(controlPoints[0]);
            const q2 = toCanvasCoords(controlPoints[1]);
            const q3 = toCanvasCoords(controlPoints[2]);
            const q4 = toCanvasCoords(controlPoints[3]);
            const q5 = toCanvasCoords(controlPoints[4]);
            
            // Draw control lines for first segment
            curveCtx.moveTo(q1.x, q1.y);
            curveCtx.lineTo(q2.x, q2.y);
            curveCtx.lineTo(q3.x, q3.y);
            
            // Draw control lines for second segment
            curveCtx.moveTo(q3.x, q3.y);
            curveCtx.lineTo(q4.x, q4.y);
            curveCtx.lineTo(q5.x, q5.y);
            
            curveCtx.stroke();
            
            // Draw bezier curves
            curveCtx.strokeStyle = 'black';
            curveCtx.lineWidth = 3;
            
            // First quadratic bezier curve (Q1, Q2, Q3)
            curveCtx.beginPath();
            curveCtx.moveTo(q1.x, q1.y);
            
            for (let t = 0; t <= 1; t += 0.01) {
                const x = (1-t)*(1-t)*controlPoints[0].x + 2*(1-t)*t*controlPoints[1].x + t*t*controlPoints[2].x;
                const y = (1-t)*(1-t)*controlPoints[0].y + 2*(1-t)*t*controlPoints[1].y + t*t*controlPoints[2].y;
                const canvasCoords = toCanvasCoords({x, y});
                curveCtx.lineTo(canvasCoords.x, canvasCoords.y);
            }
            curveCtx.stroke();
            
            // Second quadratic bezier curve (Q3, Q4, Q5)
            curveCtx.beginPath();
            curveCtx.moveTo(q3.x, q3.y);
            
            for (let t = 0; t <= 1; t += 0.01) {
                const x = (1-t)*(1-t)*controlPoints[2].x + 2*(1-t)*t*controlPoints[3].x + t*t*controlPoints[4].x;
                const y = (1-t)*(1-t)*controlPoints[2].y + 2*(1-t)*t*controlPoints[3].y + t*t*controlPoints[4].y;
                const canvasCoords = toCanvasCoords({x, y});
                curveCtx.lineTo(canvasCoords.x, canvasCoords.y);
            }
            curveCtx.stroke();
            
            // Draw control points
            controlPoints.forEach(point => {
                const canvasCoords = toCanvasCoords(point);
                
                curveCtx.fillStyle = point.color;
                curveCtx.beginPath();
                curveCtx.arc(canvasCoords.x, canvasCoords.y, point.radius, 0, Math.PI * 2);
                curveCtx.fill();
                
                curveCtx.strokeStyle = 'white';
                curveCtx.lineWidth = 2;
                curveCtx.stroke();
            });
        }
        
        // Function to update distance field
        function updateDistanceField() {
            gl.viewport(0, 0, distanceFieldCanvas.width, distanceFieldCanvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            // Set uniforms
            gl.uniform2f(p0Location, controlPoints[0].x, controlPoints[0].y);
            gl.uniform2f(p1Location, controlPoints[1].x, controlPoints[1].y);
            gl.uniform2f(p2Location, controlPoints[2].x, controlPoints[2].y);
            gl.uniform2f(p3Location, controlPoints[3].x, controlPoints[3].y);
            gl.uniform2f(p4Location, controlPoints[4].x, controlPoints[4].y);
            gl.uniform2f(iResolutionLocation, distanceFieldCanvas.width, distanceFieldCanvas.height);
            gl.uniform2f(clickPositionLocation, clickPosition.x, clickPosition.y);
            gl.uniform1i(showGradientLocation, showGradient ? 1 : 0);
            
            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        
        // Function to draw autonomous system field
        function drawAutonomousSystem() {
            const width = autonomousCanvas.width;
            const height = autonomousCanvas.height;
            
            // Get lambda value from slider
            const lambda = parseFloat(document.getElementById('lambdaSlider').value);
            
            // Clear canvas
            autonomousCtx.clearRect(0, 0, width, height);
            
            // Draw grid
            autonomousCtx.strokeStyle = '#ddd';
            autonomousCtx.lineWidth = 1;
            const gridSize = 10;
            
            for (let x = 0; x <= gridSize; x++) {
                const posX = (width / gridSize) * x;
                autonomousCtx.beginPath();
                autonomousCtx.moveTo(posX, 0);
                autonomousCtx.lineTo(posX, height);
                autonomousCtx.stroke();
            }
            
            for (let y = 0; y <= gridSize; y++) {
                const posY = (height / gridSize) * y;
                autonomousCtx.beginPath();
                autonomousCtx.moveTo(0, posY);
                autonomousCtx.lineTo(width, posY);
                autonomousCtx.stroke();
            }
            
            // Draw bezier curves
            autonomousCtx.strokeStyle = 'black';
            autonomousCtx.lineWidth = 3;
            
            // First quadratic bezier curve (Q1, Q2, Q3)
            autonomousCtx.beginPath();
            const q1 = toCanvasCoords(controlPoints[0]);
            const q2 = toCanvasCoords(controlPoints[1]);
            const q3 = toCanvasCoords(controlPoints[2]);
            
            autonomousCtx.moveTo(q1.x, q1.y);
            
            for (let t = 0; t <= 1; t += 0.01) {
                const x = (1-t)*(1-t)*controlPoints[0].x + 2*(1-t)*t*controlPoints[1].x + t*t*controlPoints[2].x;
                const y = (1-t)*(1-t)*controlPoints[0].y + 2*(1-t)*t*controlPoints[1].y + t*t*controlPoints[2].y;
                const canvasCoords = toCanvasCoords({x, y});
                autonomousCtx.lineTo(canvasCoords.x, canvasCoords.y);
            }
            autonomousCtx.stroke();
            
            // Second quadratic bezier curve (Q3, Q4, Q5)
            autonomousCtx.beginPath();
            const q4 = toCanvasCoords(controlPoints[3]);
            const q5 = toCanvasCoords(controlPoints[4]);
            
            autonomousCtx.moveTo(q3.x, q3.y);
            
            for (let t = 0; t <= 1; t += 0.01) {
                const x = (1-t)*(1-t)*controlPoints[2].x + 2*(1-t)*t*controlPoints[3].x + t*t*controlPoints[4].x;
                const y = (1-t)*(1-t)*controlPoints[2].y + 2*(1-t)*t*controlPoints[3].y + t*t*controlPoints[4].y;
                const canvasCoords = toCanvasCoords({x, y});
                autonomousCtx.lineTo(canvasCoords.x, canvasCoords.y);
            }
            autonomousCtx.stroke();
            
            // Draw vector field
            const gridSizeVectors = 15;
            const cellWidth = width / gridSizeVectors;
            const cellHeight = height / gridSizeVectors;
            
            for (let i = 0; i <= gridSizeVectors; i++) {
                for (let j = 0; j <= gridSizeVectors; j++) {
                    // Convert grid coordinates to normalized coordinates (0-1)
                    const x = i / gridSizeVectors;
                    const y = 1 - (j / gridSizeVectors);
                    
                    // Get dynamical system gradient (distance gradient)
                    const dynGradient = getBezierGradient(
                        { x, y },
                        { x: controlPoints[0].x, y: controlPoints[0].y },
                        { x: controlPoints[1].x, y: controlPoints[1].y },
                        { x: controlPoints[2].x, y: controlPoints[2].y }
                    );
                    
                    // Find closest point on both curves and get curve gradient
                    let minDist = Infinity;
                    let closestT = 0;
                    let closestSegment = 0;
                    
                    for (let t = 0; t <= 1; t += 0.001) {
                        // First segment
                        const curveX1 = (1-t)*(1-t)*controlPoints[0].x + 2*(1-t)*t*controlPoints[1].x + t*t*controlPoints[2].x;
                        const curveY1 = (1-t)*(1-t)*controlPoints[0].y + 2*(1-t)*t*controlPoints[1].y + t*t*controlPoints[2].y;
                        
                        const dist1 = Math.sqrt(
                            Math.pow(curveX1 - x, 2) + 
                            Math.pow(curveY1 - y, 2)
                        );
                        
                        if (dist1 < minDist) {
                            minDist = dist1;
                            closestT = t;
                            closestSegment = 0;
                        }
                        
                        // Second segment
                        const curveX2 = (1-t)*(1-t)*controlPoints[2].x + 2*(1-t)*t*controlPoints[3].x + t*t*controlPoints[4].x;
                        const curveY2 = (1-t)*(1-t)*controlPoints[2].y + 2*(1-t)*t*controlPoints[3].y + t*t*controlPoints[4].y;
                        
                        const dist2 = Math.sqrt(
                            Math.pow(curveX2 - x, 2) + 
                            Math.pow(curveY2 - y, 2)
                        );
                        
                        if (dist2 < minDist) {
                            minDist = dist2;
                            closestT = t;
                            closestSegment = 1;
                        }
                    }
                    
                    const curveGradient = closestSegment === 0 ? 
                        getCurveGradient(
                            { x: controlPoints[0].x, y: controlPoints[0].y },
                            { x: controlPoints[1].x, y: controlPoints[1].y },
                            { x: controlPoints[2].x, y: controlPoints[2].y },
                            closestT
                        ) :
                        getCurveGradient(
                            { x: controlPoints[2].x, y: controlPoints[2].y },
                            { x: controlPoints[3].x, y: controlPoints[3].y },
                            { x: controlPoints[4].x, y: controlPoints[4].y },
                            closestT
                        );
                    
                    // Check if we're at the end point (Q5)
                    const endPoint = { x: controlPoints[4].x, y: controlPoints[4].y };
                    const distToEnd = Math.sqrt(
                        Math.pow(x - endPoint.x, 2) + 
                        Math.pow(y - endPoint.y, 2)
                    );
                    
                    // Calculate beta and alpha based on distance
                    let beta = 1.0 / (1.0 + lambda * minDist);
                    let alpha = 1.0 - beta;
                    
                    // If we're very close to the end point, only use distance gradient
                    if (distToEnd < 0.01) {
                        beta = 0;
                        alpha = 1;
                    }
                    
                    // Combine the gradients
                    let combinedX = -alpha * (-dynGradient.x) + beta * curveGradient.tangent.x;
                    let combinedY = -alpha * (-dynGradient.y) + beta * curveGradient.tangent.y;
                    
                    // Normalize the combined vector if it's not zero
                    const length = Math.sqrt(combinedX * combinedX + combinedY * combinedY);
                    if (length > 0) {
                        combinedX = combinedX / length;
                        combinedY = combinedY / length;
                    }
                    
                    // Convert to canvas coordinates
                    const centerX = i * cellWidth;
                    const centerY = j * cellHeight;
                    
                    // Scale the gradient for better visualization
                    const arrowLength = Math.min(cellWidth, cellHeight) * 0.5;
                    
                    // Draw the vector line with color based on distance
                    const red = alpha;  // More red when following distance gradient
                    const blue = beta;  // More blue when following curve gradient
                    autonomousCtx.strokeStyle = `rgba(${red * 255}, 0, ${blue * 255}, 0.7)`;
                    autonomousCtx.lineWidth = 2;
                    
                    // Only draw the vector if it's not zero
                    if (length > 0) {
                        autonomousCtx.beginPath();
                        autonomousCtx.moveTo(centerX, centerY);
                        autonomousCtx.lineTo(
                            centerX + combinedX * arrowLength,
                            centerY - combinedY * arrowLength
                        );
                        
                        // Draw arrow head
                        const arrowSize = 6;
                        const angle = Math.atan2(-combinedY, combinedX);
                        
                        autonomousCtx.lineTo(
                            centerX + combinedX * arrowLength - arrowSize * Math.cos(angle - Math.PI/6),
                            centerY - combinedY * arrowLength - arrowSize * Math.sin(angle - Math.PI/6)
                        );
                        autonomousCtx.moveTo(
                            centerX + combinedX * arrowLength,
                            centerY - combinedY * arrowLength
                        );
                        autonomousCtx.lineTo(
                            centerX + combinedX * arrowLength - arrowSize * Math.cos(angle + Math.PI/6),
                            centerY - combinedY * arrowLength - arrowSize * Math.sin(angle + Math.PI/6)
                        );
                        
                        autonomousCtx.stroke();
                    }
                }
            }
            
            // Draw trajectory if it exists
            if (trajectory.length > 0) {
                autonomousCtx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
                autonomousCtx.lineWidth = 2;
                autonomousCtx.beginPath();
                
                const start = toCanvasCoords(trajectory[0]);
                autonomousCtx.moveTo(start.x, start.y);
                
                for (let i = 1; i < trajectory.length; i++) {
                    const point = toCanvasCoords(trajectory[i]);
                    autonomousCtx.lineTo(point.x, point.y);
                }
                
                autonomousCtx.stroke();
                
                // Draw trajectory points
                trajectory.forEach((point, index) => {
                    const canvasCoords = toCanvasCoords(point);
                    autonomousCtx.fillStyle = `rgba(255, 0, 255, ${0.8 - index * 0.8 / trajectory.length})`;
                    autonomousCtx.beginPath();
                    autonomousCtx.arc(canvasCoords.x, canvasCoords.y, 2, 0, Math.PI * 2);
                    autonomousCtx.fill();
                });
            }
            
            // Draw stream plot point
            const streamCanvasCoords = toCanvasCoords(streamPoint);
            autonomousCtx.fillStyle = 'rgba(255, 0, 255, 0.8)';
            autonomousCtx.beginPath();
            autonomousCtx.arc(streamCanvasCoords.x, streamCanvasCoords.y, 6, 0, Math.PI * 2);
            autonomousCtx.fill();
            
            autonomousCtx.strokeStyle = 'white';
            autonomousCtx.lineWidth = 2;
            autonomousCtx.stroke();

            // Draw equilibrium point (Q5)
            const eqPoint = toCanvasCoords(controlPoints[4]);
            autonomousCtx.fillStyle = '#ff7f0e';
            autonomousCtx.beginPath();
            autonomousCtx.arc(eqPoint.x, eqPoint.y, 8, 0, Math.PI * 2);
            autonomousCtx.fill();
            
            autonomousCtx.strokeStyle = 'white';
            autonomousCtx.lineWidth = 2;
            autonomousCtx.stroke();
        }
        
        // Add mouse event handlers for stream plot point
        autonomousCanvas.addEventListener('mousedown', (e) => {
            const rect = autonomousCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Convert to normalized coordinates
            const normalized = toNormalizedCoords(mouseX, mouseY);
            
            // Check if mouse is near stream point
            const streamCanvasCoords = toCanvasCoords(streamPoint);
            const distance = Math.sqrt(
                Math.pow(mouseX - streamCanvasCoords.x, 2) + 
                Math.pow(mouseY - streamCanvasCoords.y, 2)
            );
            
            if (distance <= 10) {
                streamPoint.dragging = true;
            }
        });
        
        autonomousCanvas.addEventListener('mousemove', (e) => {
            if (streamPoint.dragging) {
                const rect = autonomousCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Convert to normalized coordinates and update point
                const normalized = toNormalizedCoords(mouseX, mouseY);
                streamPoint.x = Math.max(0, Math.min(1, normalized.x));
                streamPoint.y = Math.max(0, Math.min(1, normalized.y));
                
                // Compute new trajectory
                trajectory = computeTrajectory(streamPoint);
                
                // Update all visualizations
                updateAll();
            }
        });
        
        autonomousCanvas.addEventListener('mouseup', () => {
            streamPoint.dragging = false;
        });
        
        autonomousCanvas.addEventListener('mouseleave', () => {
            streamPoint.dragging = false;
        });
        
        // Add touch support for stream plot point
        autonomousCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = autonomousCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            // Convert to normalized coordinates
            const normalized = toNormalizedCoords(mouseX, mouseY);
            
            // Check if touch is near stream point
            const streamCanvasCoords = toCanvasCoords(streamPoint);
            const distance = Math.sqrt(
                Math.pow(mouseX - streamCanvasCoords.x, 2) + 
                Math.pow(mouseY - streamCanvasCoords.y, 2)
            );
            
            if (distance <= 10) {
                streamPoint.dragging = true;
            }
        });
        
        autonomousCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (streamPoint.dragging) {
                const rect = autonomousCanvas.getBoundingClientRect();
                const touch = e.touches[0];
                const mouseX = touch.clientX - rect.left;
                const mouseY = touch.clientY - rect.top;
                
                // Convert to normalized coordinates and update point
                const normalized = toNormalizedCoords(mouseX, mouseY);
                streamPoint.x = Math.max(0, Math.min(1, normalized.x));
                streamPoint.y = Math.max(0, Math.min(1, normalized.y));
                
                // Compute new trajectory
                trajectory = computeTrajectory(streamPoint);
                
                // Update all visualizations
                updateAll();
            }
        });
        
        autonomousCanvas.addEventListener('touchend', () => {
            streamPoint.dragging = false;
        });
        
        // Add mouse event handlers for control points
        curveCanvas.addEventListener('mousedown', (e) => {
            const rect = curveCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Check if mouse is inside any control point
            controlPoints.forEach(point => {
                if (isPointInControlPoint(mouseX, mouseY, point)) {
                    point.dragging = true;
                }
            });
        });
        
        curveCanvas.addEventListener('mousemove', (e) => {
            const rect = curveCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Convert to normalized coordinates
            const normalized = toNormalizedCoords(mouseX, mouseY);
            
            // Update dragging control points
            let anyDragging = false;
            controlPoints.forEach((point, index) => {
                if (point.dragging) {
                    // For Q2 and Q4, maintain C1 continuity
                    if (index === 1) { // Q2
                        const dx = normalized.x - point.x;
                        const dy = normalized.y - point.y;
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                        
                        // Update Q4 to maintain C1 continuity
                        controlPoints[3].x = Math.max(0, Math.min(1, controlPoints[2].x - (point.x - controlPoints[2].x)));
                        controlPoints[3].y = Math.max(0, Math.min(1, controlPoints[2].y - (point.y - controlPoints[2].y)));
                    } else if (index === 3) { // Q4
                        const dx = normalized.x - point.x;
                        const dy = normalized.y - point.y;
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                        
                        // Update Q2 to maintain C1 continuity
                        controlPoints[1].x = Math.max(0, Math.min(1, controlPoints[2].x - (point.x - controlPoints[2].x)));
                        controlPoints[1].y = Math.max(0, Math.min(1, controlPoints[2].y - (point.y - controlPoints[2].y)));
                    } else if (index === 2) { // Q3
                        // When moving Q3, maintain C1 continuity by updating both Q2 and Q4
                        const dx = normalized.x - point.x;
                        const dy = normalized.y - point.y;
                        
                        // Calculate new positions for Q2 and Q4 to maintain the constraint
                        const newQ2x = controlPoints[1].x + dx;
                        const newQ2y = controlPoints[1].y + dy;
                        const newQ4x = controlPoints[3].x + dx;
                        const newQ4y = controlPoints[3].y + dy;
                        
                        // Update Q3
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                        
                        // Update Q2 and Q4 while maintaining the constraint
                        controlPoints[1].x = Math.max(0, Math.min(1, newQ2x));
                        controlPoints[1].y = Math.max(0, Math.min(1, newQ2y));
                        controlPoints[3].x = Math.max(0, Math.min(1, newQ4x));
                        controlPoints[3].y = Math.max(0, Math.min(1, newQ4y));
                    } else {
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                    }
                    anyDragging = true;
                }
            });
            
            if (anyDragging) {
                updateAll();
            }
        });
        
        curveCanvas.addEventListener('mouseup', () => {
            controlPoints.forEach(point => {
                point.dragging = false;
            });
        });
        
        curveCanvas.addEventListener('mouseleave', () => {
            controlPoints.forEach(point => {
                point.dragging = false;
            });
        });
        
        // Add touch support for control points
        curveCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = curveCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            // Check if touch is inside any control point
            controlPoints.forEach(point => {
                if (isPointInControlPoint(mouseX, mouseY, point)) {
                    point.dragging = true;
                }
            });
        });
        
        curveCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = curveCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            // Convert to normalized coordinates
            const normalized = toNormalizedCoords(mouseX, mouseY);
            
            // Update dragging control points
            let anyDragging = false;
            controlPoints.forEach((point, index) => {
                if (point.dragging) {
                    // For Q2 and Q4, maintain C1 continuity
                    if (index === 1) { // Q2
                        const dx = normalized.x - point.x;
                        const dy = normalized.y - point.y;
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                        
                        // Update Q4 to maintain C1 continuity
                        controlPoints[3].x = Math.max(0, Math.min(1, controlPoints[2].x - (point.x - controlPoints[2].x)));
                        controlPoints[3].y = Math.max(0, Math.min(1, controlPoints[2].y - (point.y - controlPoints[2].y)));
                    } else if (index === 3) { // Q4
                        const dx = normalized.x - point.x;
                        const dy = normalized.y - point.y;
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                        
                        // Update Q2 to maintain C1 continuity
                        controlPoints[1].x = Math.max(0, Math.min(1, controlPoints[2].x - (point.x - controlPoints[2].x)));
                        controlPoints[1].y = Math.max(0, Math.min(1, controlPoints[2].y - (point.y - controlPoints[2].y)));
                    } else if (index === 2) { // Q3
                        // When moving Q3, maintain C1 continuity by updating both Q2 and Q4
                        const dx = normalized.x - point.x;
                        const dy = normalized.y - point.y;
                        
                        // Calculate new positions for Q2 and Q4 to maintain the constraint
                        const newQ2x = controlPoints[1].x + dx;
                        const newQ2y = controlPoints[1].y + dy;
                        const newQ4x = controlPoints[3].x + dx;
                        const newQ4y = controlPoints[3].y + dy;
                        
                        // Update Q3
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                        
                        // Update Q2 and Q4 while maintaining the constraint
                        controlPoints[1].x = Math.max(0, Math.min(1, newQ2x));
                        controlPoints[1].y = Math.max(0, Math.min(1, newQ2y));
                        controlPoints[3].x = Math.max(0, Math.min(1, newQ4x));
                        controlPoints[3].y = Math.max(0, Math.min(1, newQ4y));
                    } else {
                        point.x = Math.max(0, Math.min(1, normalized.x));
                        point.y = Math.max(0, Math.min(1, normalized.y));
                    }
                    anyDragging = true;
                }
            });
            
            if (anyDragging) {
                updateAll();
            }
        });
        
        curveCanvas.addEventListener('touchend', () => {
            controlPoints.forEach(point => {
                point.dragging = false;
            });
        });
        
        // Add mouse event handlers for distance field
        distanceFieldCanvas.addEventListener('mousedown', (e) => {
            const rect = distanceFieldCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Convert to normalized coordinates
            const normalized = toNormalizedCoords(mouseX, mouseY);
            
            // Update click position and show gradient
            clickPosition.x = normalized.x;
            clickPosition.y = normalized.y;
            showGradient = true;
            
            updateAll();
        });
        
        distanceFieldCanvas.addEventListener('mousemove', (e) => {
            if (e.buttons === 1) { // Only if left mouse button is pressed
                const rect = distanceFieldCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Convert to normalized coordinates
                const normalized = toNormalizedCoords(mouseX, mouseY);
                
                // Update click position
                clickPosition.x = normalized.x;
                clickPosition.y = normalized.y;
                
                updateAll();
            }
        });
        
        distanceFieldCanvas.addEventListener('mouseup', () => {
            showGradient = false;
            updateAll();
        });
        
        // Add touch support for distance field
        distanceFieldCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = distanceFieldCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            // Convert to normalized coordinates
            const normalized = toNormalizedCoords(mouseX, mouseY);
            
            // Update click position and show gradient
            clickPosition.x = normalized.x;
            clickPosition.y = normalized.y;
            showGradient = true;
            
            updateAll();
        });
        
        distanceFieldCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = distanceFieldCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            // Convert to normalized coordinates
            const normalized = toNormalizedCoords(mouseX, mouseY);
            
            // Update click position
            clickPosition.x = normalized.x;
            clickPosition.y = normalized.y;
            
            updateAll();
        });
        
        distanceFieldCanvas.addEventListener('touchend', () => {
            showGradient = false;
            updateAll();
        });
        
        // Add event listener for lambda slider
        const lambdaSlider = document.getElementById('lambdaSlider');
        const lambdaValue = document.getElementById('lambdaValue');
        
        lambdaSlider.addEventListener('input', () => {
            lambdaValue.textContent = lambdaSlider.value;
            updateAll();
        });
        
        // Initial draw
        trajectory = computeTrajectory(streamPoint);
        updateAll();
    </script>

    <div class="gif-section">
        <h2>Applications to Real Robot</h2>
        <div class="gif-container">
            <div class="gif-item">
                <h4>Disturbance Handling</h4>
                <img src="disturbance.gif" alt="Distance Field Evolution">
                <!-- <p>Visualization of how the distance field evolves as the curve is modified.</p> -->
            </div>
            <div class="gif-item">
                <h4>Pick and Place</h4>
                <img src="pick_and place.gif" alt="Dynamical System Flow">
                <!-- <p>Demonstration of the dynamical system's flow for different initial conditions.</p> -->
            </div>
            <div class="gif-item">
                <h4>Human-Robot Interaction</h4>
                <img src="hri1x.gif" alt="Trajectory Convergence">
                <img src="hrc.gif" alt="Trajectory Convergence">
                <!-- <p>Multiple trajectories converging to the equilibrium point along the curve.</p> -->
            </div>
        </div>
    </div>
</body>
</html>
